Program (args) {         
        rdSortEnv = new TaskEnvironment(name: "Radix Sort")
       
        bind_input(rdSortEnv, "keys", args.input_file)
        bind_output(rdSortEnv, "keys", args.output_file)

        digits = args.digits
        key_size = args.key_size
        p = args.p
        execute("Radix Sort"; rdSortEnv; Initialize: digits, key_size; Partition: p)
}

Task "Radix Sort":
	Define:
		keys, scatter_offsets, l: 1D Array of Integer
		f: 1D Array of Boolean
		g: 2D Array of Integer
		radix, digits, round, r: Integer
		sorting_rounds: Range
		t: Epoch
	Environment:
		keys: link
	Initialize (digits, key_size):
		radix = digits ** 2
		scatter_offsets.dimension = f.dimension = l.dimension = keys.dimension
		g.dimension1.range.min = 0
		g.dimension1.range.max = partition.p - 1
		g.dimension2.range.min = 0
		g.dimension2.range.max = radix - 1
		sorting_rounds.min = 0
		sorting_rounds.max = key_size / digits - 1
	Compute:
		// calculate the number of keys having different values for the current digit place in each partition
		"Upsweep Reduction" (Space B) {
			// determine which keys in the array have r in the current digit place 
			"Digit Decoding" (Space B) {
				value = r << (digits ** round)
				do { 
					if ((keys[i] & value) == value) { l[i] = 1 
					} else { l[i] = 0 }
				} for i in keys
			}
			// determine the total number of local keys that have 1 in the current digit place for value r
			"Local Reduction" (Space B) {
				do { total_ones = reduce("sum", l[i]) } for i in l
				local_reduce_index = g.local.dimension1.range.min
				g[local_reduce_index][r] = total_ones
			}
			// iterate the local keys for all r values and do the above two steps
			Repeat: from "Digit Decoding" for r in g.dimension2.range
		}
		// determine the starting offsets for the entries belonging to different partitions for various values for 
		// the current digit place
		"Top Level Scan" (Space A) {
			do in sequence {
				// add the last distribution offset for the immediate lower value to set the offset of the 
				// first key with rd at the current digit place  					
				if (rd > 0) { 
					g[0][rd] = g[0][rd] + g[g.dimension1.range.max][rd - 1] 
				}
				// do a prefix scan of entries for a particular value rd in the current digit place to 
				// determine the offsets of keys relative to the first key
				do in sequence {	
					g[i][rd] = g[i][rd] + g[i - 1][rd]
				} for i in g.dimension1.range and i > 0
			} for rd in g.dimension2.range
		}
		// calculate the exact offsets of all local keys within a partition using the information of the starting
		// offset of first key with a particular value in the current digit place
		"Downsweep Scatter" (Space B) {
			// again, determine which keys in the array have r in the current digit place 
			"Flag Vector Generation" (Space B) {
				value = r << (digits ** round)
				do { f[i] = ((keys[i] & value) == value) } for i in keys
			}
			// determine the distribution offsets of keys respective to the first key with r at the digit place
			"Local Scan" (Space B) {
				do {	
					if (f[i]) { l[i] = 1 } else { l[i] = 0 }
				} for i in f
				first_index = l.local.dimension1.range.min
				l[first_index] = l[first_index] + g[g.local.dimension1.range.min][r]
				do in sequence {	
					l[i] = l[i] + l[i - 1]
				} for i in l.dimension1.range and i > first_index
			}
			// store the positions where the local keys should go in next
			"Assign Scatter Offsets" (Space B) {
				do { if (f[i]) { scatter_offsets[i] = l[i] } } for i in f
			}
			// do the offset calculation for all possible values in the current digit place
			Repeat: from "Flag Vector Generation" for r in g.dimension2.range
		}
		// finally shuffle the keys based on the calculated scatter offsets to finish one round of distribution sort
		"Rearrange Input Sequence" (Space A) {
			do { keys[i] at (t) = keys[scatter_offsets[i]] at (t - 1) } for i in keys
		}
		// repeat from the beginning to have as many rounds of distribution sort as required by the size of the keys
		Repeat: from "Upsweep Reduction" for round in sorting_rounds
	Partition (p):
		Space A <un-partitioned> { 
			keys, g, scatter_offsets 
		}
		Space B <1D> divides Space A partitions { 
			keys, scatter_offsets, f, l: block_count(p)
			g<dim1>: block_size(1) 
		}
