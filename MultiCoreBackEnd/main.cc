/* File: main.cc
 * -------------
 * This file defines the main() routine for the program and not much else.
 */
 
#include <iostream>
#include <string.h>
#include <stdio.h>

#include "parser.h"
#include "scanner.h"
#include "codegen/code_generator.h"	
#include "codegen/thread_state_mgmt.h"	
#include "codegen/space_mapping.h"
#include "utils/list.h"
#include "syntax/ast.h"
#include "syntax/ast_def.h"
#include "syntax/errors.h"
#include "syntax/ast_task.h"

int main(int argc, char *argv[]) {
	
	//*************************************************************** Front End Compiler
 	/* Entry point to the entire program. InitScanner() is used to set up the scanner.
	 * InitParser() is used to set up the parser. The call to yyparse() will attempt to
	 * parse a complete program from the input. 
	 */	
    	InitScanner(); InitParser(); yyparse();
	if (ReportError::NumErrors() > 0) return -1;
	// Do scope and type checking and other semantic analysis on the program definition 
	// generated by the parser
	ProgramDef::program->attachScope(NULL);
        ProgramDef::program->validateScope(NULL);
	if (ReportError::NumErrors() > 0) return -1;
	// Do static analysis analysis on the validated program
	ProgramDef::program->performStaticAnalysis();	
	if (ReportError::NumErrors() > 0) return -1;
	//**********************************************************************************



	//**************************************************************** Back End Compiler
	const char *programFile = "build/output.cc";
	initializeOutputFile(programFile);
	List<PPS_Definition*> *pcubesConfig = parsePCubeSDescription("/home/yan/pcubes.ml");
	TaskDef *luTask = (TaskDef*) ProgramDef::program->getTaskDefinition("LU Factorization");
	if (luTask == NULL) std::cout << "could not find LU factorization task\n";
	PartitionHierarchy *lpsHierarchy = luTask->getPartitionHierarchy();
	MappingNode *mappingConfig = parseMappingConfiguration("LU Factorization",
        		"/home/yan/opteron-solver-mapping.map", lpsHierarchy, pcubesConfig);
	// generate macro definitions needed for various reasons
	generateLPSMacroDefinitions(programFile, mappingConfig);
	generatePPSCountMacros(programFile, pcubesConfig);
	generateThreadCountMacros(programFile, mappingConfig, pcubesConfig);
	// generate library routines for LPUs management	
	List<Identifier*> *partitionArgs = luTask->getPartitionArguments();
	Hashtable<List<PartitionParameterConfig*>*> *partitionFnParamConfigs 
			= generateLPUCountFunctions(programFile, mappingConfig, partitionArgs);
	Hashtable<List<int>*> *lpuPartFnParamsConfigs 
			= generateAllGetPartForLPURoutines(programFile, mappingConfig, partitionArgs);
	// generate task specific data structures 
	generateLpuDataStructures(programFile, mappingConfig);
	generateArrayMetadataAndEnvLinks(programFile, mappingConfig, 
			luTask->getEnvironmentLinks());
	// generate thread management functions and classes
	generateFnForThreadIdsAllocation(programFile, mappingConfig, pcubesConfig);
	generateThreadStateImpl(programFile, mappingConfig, 
			partitionFnParamConfigs, lpuPartFnParamsConfigs);
}

