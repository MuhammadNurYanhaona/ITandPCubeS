Tuple Point:
	x, y: Real single-precision

Tuple Rectangle:
	top, right, bottom, left: Integer

Tuple Coefficients:
	order: Integer
	values: Array[2] of Real single-precision

// A Monte-Carlo area estimation task that determines the area under a curve. A rectangular grid
// surrounds the curve and the grid is partitioned into sections to be handled by different LPUs.
// Each the computation for each section continues until the estimate for that section reaches a
// desirable precision. Finally, the total area is calculated by summing up the areas estimated
// for the curve in individual sections.   
Task "Monte Carlo Area Estimation":
	Define:
		// a list of coefficients represents the equation for the curve
		shape: List of Coefficients
		// the 2D array representing the rectangular grid 
		grid: 2D Array of Rectangle
		// a 2D array used to hold the estimate of the curve within each grid section 
		subarea_estimate: 2D Array of Real single-precision
		// an auxiliary array to temporarily hold the relative position of a generated
		// point relative to the give curve 
		point_placements: 3D Array of Integer
		t: Epoch
		area, cell_size, precision, precision_local: Real single-precision
	Environment:
		grid, shape: link
		area: create
	Initialize (precision, cell_size):
		subarea_estimate.dimension = grid.dimension
		point_placements.dimension1 = grid.dimension1
		point_placements.dimension2 = grid.dimension2
		point_placements.dimension3.range.min = 0	
		point_placements.dimension3.range.max = partition.p - 1	
	Compute:
		"Calculate Point Position" (Space A) {
			do { 
				point = generatePoint(grid[i][j])
				point_placements[i][j][k] = computePosition(shape, point)
			} for i, j, k in point_placements
		}
		"Refine Subarea Estimate" (Space B) {
			local_points = point_placements.dimension3.length
			do { 
				do {
					internal_points = reduce ("sum", point_placements[i][j][k])
				} for k in point_placements
				external_points = local_points - internal_points
				total_inside at (t) = total_inside at (t - 1) + internal_points
				total_outside at (t) = total_outside at (t - 1) + external_points
				total_points = (total_inside + total_outside) at (t)
				subarea_estimate[i][j] at (t) 					\
					= cell_size * (total_inside / total_points) at (t)
				precision_local = subarea_estimate[i][j] at (t) 		\
						- subarea_estimate[i][j] at (t - 1)
			} for i, j in subarea_estimate
		}
		Repeat: from "Calculate Point Position" while precision_local > precision
		"Estimate Total Area" (Space C) {
			do {
				area = reduce ("sum", subarea_estimate[i][j])
			} for i, j in subarea_estimate
		}
	Partition(p):
		Space C <un-partitioned> { subarea_estimate }
		Space B <2D> divides Space C partitions {
			point_placements<dim1, dim2>: block_size (1, 1)
			grid, subarea_estimate: block_size (1, 1)
		}
		Space A <1D> divides Space B partitions {
			point_placements<dim3>: block_count (p)
			grid: replicated
		}

// function for generating a random point within a rectangular boundary
Function generatePoint:
	Arguments: 
		boundary: Rectangle
	Results:
		point: Point
	Compute:
		height = boundary.top - boundary.bottom
		width = boundary.right - boundary.left
		point.y = random() * 1.0 / height + boundary.bottom
		point.x = random() * 1.0 / width + boundary.left

// a mock implementation that does nothing
Function computePosition:
	Arguments:
		shape: List of Coefficients
		point: Point
	Results:
		position: Integer
	Compute:
		position = 1
