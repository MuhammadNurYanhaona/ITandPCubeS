## 
## Simple makefile for decaf programming projects
##


.PHONY: clean strip

# Set the default target. When you make with no arguments, this will be the target built.
COMPILER = icc
PRODUCTS = $(COMPILER) 
default: $(PRODUCTS)

# Set up the list of source and object files
SRCS = $(shell find . ! -name "hashtable.cc" -name "*.cc" -not -path "./build/*")

# Set up the list of source to compile generated code for any IT program
BUILD_SRCS = $(shell find . -name "*.cc" -not -name "hashtable.cc" -not -name "main.cc")

# OBJS can deal with either .cc or .c files listed in SRCS
OBJS = y.tab.o lex.yy.o $(patsubst %.cc, %.o, $(filter %.cc,$(SRCS))) $(patsubst %.c, %.o, $(filter %.c, $(SRCS)))

# objects for compiling any generated code for IT program
BUILD_OBJS = y.tab.o lex.yy.o $(patsubst %.cc, %.o, $(filter %.cc, $(BUILD_SRCS)))

JUNK =  *.o */*.o lex.yy.c dpp.yy.c y.tab.c y.tab.h *.core core $(COMPILER).purify purify.log

# log files generated by running any compiled IT program
BUILD_LOGS = ./bin/*.log 

# Define the tools we are going to use
CC= g++
LD = g++
LEX = flex
YACC = bison

# Set up the necessary flags for the tools

# We want debugging and most warnings, but lex/yacc generate some
# static symbols we don't use, so turn off unused warnings to avoid clutter
# STL has some signed/unsigned comparisons we want to suppress
CFLAGS = -g  -Wall -Wno-unused -Wno-sign-compare 

# We need flag to enable the POSIX thread library during compiling generated code
RFLAG = -pthread

# The -d flag tells lex to set up for debugging. Can turn on/off by
# setting value of global yy_flex_debug inside the scanner itself
LEXFLAGS = -d

# The -d flag tells yacc to generate header with token types
# The -v flag writes out a verbose description of the states and conflicts
# The -t flag turns on debugging capability
# The -y flag means imitate yacc's output file naming conventions
YACCFLAGS = -dvty

# Link with standard c library, math library, and lex library
LIBS = -lc -lm -lfl

# Link with POSIX thread library
BUILD_LIBS = -pthread

# Rules for various parts of the target

.yy.o: $*.yy.c
	$(CC) $(CFLAGS) -c -o $@ $*.cc

lex.yy.c: IT.l IT.y y.tab.h 
	$(LEX) $(LEXFLAGS) IT.l

y.tab.o: y.tab.c
	$(CC) $(CFLAGS) -c -o y.tab.o y.tab.c

y.tab.h y.tab.c: IT.y
	$(YACC) $(YACCFLAGS) IT.y

.cc.o: $*.cc
	$(CC) $(CFLAGS) $(RFLAG) -c -o $@ $*.cc

# rules to build compiler (icc)
$(COMPILER) : $(OBJS)
	$(LD) -o $@ $(OBJS) $(LIBS)

$(COMPILER).purify : $(OBJS)
	purify -log-file=purify.log -cache-dir=/tmp/$(USER) -leaks-at-exit=no $(LD) -o $@ $(OBJS) $(LIBS)


# This target is to build small for testing (no debugging info), removes
# all intermediate products, too
strip : $(PRODUCTS)
	strip $(PRODUCTS)
	rm -rf $(JUNK)


# make depend will set up the header file dependencies. You should make 
# depend whenever you add a new header file to the project or move the 
# project between machines
#
depend:
	makedepend -- $(CFLAGS) -- $(SRCS)

clean:
	rm -f $(JUNK) y.output $(PRODUCTS) $(BUILD_LOGS)

# make build will compile and generate executable for any IT program compiled by the IT compiler 
build: $(BUILD_OBJS)
	$(LD) -o ./bin/it-program.o $(BUILD_OBJS) $(LIBS) $(BUILD_LIBS)
	

