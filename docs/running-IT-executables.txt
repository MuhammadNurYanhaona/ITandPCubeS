Note that your IT source code is supposed to have one or more tasks with a program coordinator function, 
called Program, that launches those tasks in their proper order with appropriate arguments. The program 
coordinator function itself takes a single argument that is supposed to hold all command line arguments 
you passed when running the executable. The single argument of the coordinator function is an associated 
map of <key, value> pairs and allows these values to be accessed within the program body as properties 
of the map. The following code snippet gives an example of how it works.

Program(arg) {
	blockSize = arg.b
	...
}

In the above, the command line argument b is assigned to the blockSize variable within the controller
program for some later use. To make the argument b available at runtime, the associated executable 
should be invoked with a command line argument with the key 'b.' The format for specifying a command
line argument is 'key=value.' Assume for an example that the executable for our source program, call 
it test, needs two command line arguments: one for an input file 'input_file' and another is 'b.' Then 
to run the executable use the following syntax if it is generated by the multicore-backend compiler.

./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

To run the executable generated by the segmented-backend compiler, you need some MPI command such as 
mpirun. Therefore the eariler line should rather look something like the following.

mpirun ./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

Note that the backend compilers uses binary files for input/output. There are several tools in the 
../tools directory that you can use to generate random text and binary files and convert from one form
to the other. If you want to use input/output files that you got from some  other sources, make sure 
the file format matches the format expected by executables generated by IT compilers. To verify if 
your input file format is correct, just generate some sample files using the tools available and then 
compare your files against those. You may need to write your own little code to  convert your input 
file to a format appropriate for IT executable. The same is true for the output file, obviously, right? 
