Note that your IT source code is supposed to have one or more tasks with a coordinator program, called
Program, that launches those tasks in their proper order with appropriate arguments. The controller 
program itself takes a single argument that is supposed to hold all command line arguments you passed
when running the executable. The single argument of the controller program is an associated map of 
<key, value> pairs and allows these values to be accessed within the program body as properties of the 
map. The following code snippet gives an example of how it works.

Program(arg) {
	blockSize = arg.b
	...
}

In the above, the command line argument b is assigned to the blockSize variable within the controller
program for some later use. To make the argument b available at runtime, the associated executable 
should be invoked with a command line argument with the key 'b.' The format for specifying a command
line argument is 'key=value.' Assume for an example that the executable for our source program, call 
it test, needs two command line arguments: one for an input file 'input_file' and another is 'b.' Then 
to run the executable use the following syntax if it is generated by the Multicore compiler.

./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

To run the executable generated by the SegmentedMemory compiler, you need some MPI command such as 
mpirun. Therefore the eariler line should rather look something like the following.

mpirun ./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

Note that the Segmented-Memory compiler uses binary files for input/output. On the other hand, the 
Multicore compiler uses text files. There are several tools in the ../tools directory that you can use 
to generate random text and binary files. If you want to use input/output files that you got from some 
other sources, make sure the file format matches the format expected by executables generated by IT 
compilers. To verify if your input file format is correct, just generate some sample files using the 
tools available and then compare your files against those. You may need to write your own little code to 
convert your input file to a format appropriate for IT executable. The same is true for the output file, 
obviously, right? 

Furthermore, check the sample codes in the ../samples/ directory to find out what commands to use for 
using input/output files in an IT programs. Broadly speaking, you should use 'bind_input' and 
'bind_output' for programs intended for segmented-memory compiler, and 'load_array' and 'store_array' 
for programs intended for multicore compiler. Yes, we were too lazy to enable all features in both 
compilers.

But you know, you can generate multicore executables using the SegmentedMemory compiler too! Isn't this 
crazy? This is possible because the second compiler incorporates the first as a component. There may be 
performance variances in equivalent executables generated by the two compilers though, even when running 
them in the same multicore machine. This is because there are differences in how they do memory 
managements. At any rate, you can measure the performance differences to have some fun with the two 
compilers.

How does this work by the way? The mechanism for generating executables for a multicore machine using the
Segmented-Memory compiler? The idea is straightforward, you have to provide mapping for the default Root
LPS for all tasks of your IT program in the mapping configuration file. The Root is un-partitioned and
is the top-most LPS in each task's partition hierarchy. So if you map the Root to a PPS that is on or
below the segmentation level of your target architecture then the executable will use only one machine.
Using the same technique, you can generate an executable that will only use a subset of machines from a
supercomputer or cluster. Don't misspell the Root. It should appear exactly as 'Root' in the mapping file.   

Also note that executables generated by the multicore compiler will ask you if you really want to read
data structures from files. If you answer NO then it will give you the chance to tell the executable to
randomly initialize those data structures. It will similarly ask you if you really want to save an output
to a file. This mechanism was initially provided for debugging purposes. Later we did not get rid of it
as it comes in handy quite often. So our advise is run your multicore executable once in our own machine
to see what questions it asks you before you try to do any scripting with it.

Furthermore, the multicore compiler will generate a coordinator program automatically if your source file
has just one task and there is no coordinator program already. We discourage you to use this feature, as
then you wont be able to pass command line arguments while running an executable generated that way.

An executable generated by the Segmented-Memory compiler will not ask any such questions. It always reads
from input files and writes to output files.  

If all these instructions confuse you then just check the examples in the CompilerDirectory/samples/code/ 
directory of the compiler you are interested to play with. Everything will be clear.

Finally, if you are still confused -- and not pulling our legs -- then know that we are just one email 
away from you and ready to answer any question.   
