If you do not now how to generate the executable for your IT source code then read the instructions in 
COMPILATION.txt first. Then come back to this file to know how to run the executable.

Note that your IT source code is supposed to have one or more tasks with a coordinator program, called
Program, that launches those tasks in their proper order with appropriate arguments. The controller 
program itself takes a single argument that is supposed to hold all command line arguments you passed
when running the executable. The single argument of the controller program is an associated map of 
<key, value> pairs and allows these values to be accessed within the program body as properties of the 
map. The following code snippet gives an example of how it works.

Program(arg) {
	blockSize = arg.b
	...
}

In the above, the command line argument b is assigned to the blockSize variable within the controller
program for some later use. To make the argument b available at runtime, the associated executable 
should be invoked with a command line argument with the key 'b.' The format for specifying a command
line argument is 'key=value.' Assume for an example that the executable for our source program, call 
it test, needs two command line arguments: one for an input file 'input_file' and another is 'b.' Then 
to run the executable use the following syntax if it is generated by the Multicore compiler.

./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

To run the executable generated by the SegmentedMemory compiler, you need some MPI command such as 
mpirun. Therefore the eariler line should rather look something like the following.

mpirun ./test input_file=$PATH_TO_THE_INPUT_FILE b=$VALUE_FOR_B

When running the MPI program using a script on a PBS or Slurm Queue, make sure that the number of nodes
you requested in the script is equal to the number of nodes you need to run the generated executable.

Note that the SegmentedMemory compiler uses binary files for input/output. On the other hand, the 
Multicore compiler uses text files. There are several tools in the SegmentedMemoryBackEnd/tools/ directory
that you can use to generate random text and binary files. If you want to use input/output files that 
you got from some other source, make sure the file format matches the format expected by executables
generated by IT compilers. To verify if your input file format is correct, just generate some sample 
files using the tools available and then compare your files against those. You may need to write your own 
little code to convert your input file to a format appropriate for IT executable. The same is true for the 
output file, obviously, right? 

Furthermore, check the sample codes in the $CompilerDirectory/sample/code/ to find out what commands 
to use for using input/output files in an IT programs. Broadly speaking, you should use 'bind_input' and
'bind_output' for programs intended for segmented-memory compiler, and 'load_array' and 'store_array' for 
programs intended for multicore compiler. Yes, we were too lazy to enable all features in both compilers.

But you know, you can generate multicore executables using the SegmentedMemory compiler too! Isn't this 
crazy? This is possible because the second compiler incorporates the first as a component. There may be 
performance variances in equivalent executables generated by the two compilers though, even when running 
them in the same multicore machine. This is because there are differences in how they do memory 
managements. At any rate, you can measure the performance differences to have some fun with the two 
compilers.

How does this work by the way? The mechanism for generating executables for a multicore machine using the
SegmentedMemory compiler? The idea is straightforward, you have to provide mapping for the default Root
LPS for all tasks of your IT program in the mapping configuration file. The Root is un-partitioned and
is the top-most LPS in each task's partition hierarchy. So if you map the Root to a PPS that is on or
below the segmentation level of your target architecture then the executable will use only one machine.
Using the same technique, you can generate an executable that will only use a subset of machines from a
supercomputer or cluster. Don't misspell the Root. It should appear exactly as 'Root' in the mapping file.   

Also note that executables generated by the multicore compiler will ask you if you really want to read
data structures from files. If you answer NO then it will give you the chance to tell the executable to
randomly initialize those data structures. It will similarly ask you if you really want to save an output
to a file. This mechanism was initially provided for debugging purposes. Later we did not get rid of it
as it comes in handy quite often. So our advise is run your multicore executable once in our own machine
to see what questions it asks you before you try to do any scripting with it.

An executable generated by the SegmentedMemory compiler will not ask any such questions. It always reads
from input files and writes to output files.  

If all these instructions confuse you then just check the examples in the CompilerDirectory/samples/code/ 
directory of the compiler you are interested to play with. Everything will be clear.

Finally, if you are still confused -- and not pulling our legs -- then know that we are just one email 
away from you and ready to answer any question.   
   
Yan: mny9md@virginia.edu
Andrew: grimshaw@virginia.edu

