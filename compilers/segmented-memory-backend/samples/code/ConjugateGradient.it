Program (args) {
	// creating environment objects for component tasks
        vaEnv = new TaskEnvironment(name: "Vector Addition")
        dpEnv = new TaskEnvironment(name: "Vector Dot Product")        
        mvmEnv = new TaskEnvironment(name: "CSR Matrix Vector Multiply")
        
        // make the argument sparse matrix stored in compressed row format from files to be read during first-time 
        // execution of the matrix-vector multiply task
        bind_input(mvmEnv, "columns", args.arg_matrix_cols)
        bind_input(mvmEnv, "rows", args.arg_matrix_rows)
        bind_input(mvmEnv, "values", args.arg_matrix_values)

        // similarly bind the prediction and known vectors to the tasks' environment that
        // use them initially   
        bind_input(vaEnv, "u", args.known_vector)
        bind_input(mvmEnv, "v", args.prediction_vector)

        // run the conjugate gradient logic
        // note that here iteration should continue until the estimate for solution vector converges to its actual 
        // value. That should happen if the residual error is zero. But we are doing an max-iterations based 
        // termination as we do not know if the symmetric, sparse matrix is positive-definite with a spectral radius 
        // less than 1
        iteration = 0
        maxIterations = args.maxIterations
	        do {    
                // calculate A * x_i
                execute("CSR Matrix Vector Multiply"; mvmEnv; Partition: args.r)
                
                // determine the current residual error as r_i = b - A * x_i
                vaEnv.alpha = 1
                vaEnv.v = mvmEnv.w
                vaEnv.beta = -1
                execute("Vector Addition"; vaEnv; Partition: args.b)
                r_i = vaEnv.w

                // determine the dot product of r_i to itself as the residual norm
                dpEnv.u = dpEnv.v = r_i
                execute("Vector Dot Product"; dpEnv; Partition: args.b)
                norm = dpEnv.product
                
                // determine A * r_i
                mvmEnv.v = r_i
                execute("CSR Matrix Vector Multiply"; mvmEnv; Partition: args.r)

                // determine dot product of r_i to A * r_i
                dpEnv.v = mvmEnv.w
                execute("Vector Dot Product"; dpEnv; Partition: args.b)

                // determine the next step size alpha_i as (r_i.r_i) / (r_i.(A * r_i))
                alpha_i = norm / dpEnv.product

                // calculate the next estimate x_i = x_i + alpha_i * r_i
                vaEnv.u = x_i
                vaEnv.alpha = 1
                vaEnv.v = r_i
                vaEnv.beta = alpha_i            
                execute("Vector Addition"; vaEnv; Partition: args.b)

                // prepare for the next iteration
                x_i = vaEnv.w
                mvmEnv.v = x_i
                vaEnv.u = b     
                iteration = iteration + 1

        } while iteration < maxIterations and norm > args.precision

        // store the final solution vector in an output file
        bind_output(vaEnv, "w", args.solution_vector)
}

Task "Vector Addition":
	Define:
		u, v, w: 1D Array of Real double-precision
		alpha, beta: Real double-precision
	Environment:
		u, v, alpha, beta: link
		w: create
	Initialize:
		w.dimension = u.dimension
	Compute:
		"" (Space A) { do { w[i] = alpha * u[i] + beta * v[i] } for i in u }
	Partition(b):
		Space A <1D> { u, v, w: block_size(b) }

Task "Vector Dot Product":
	Define:
		u, v: 1D Array of Real double-precision
		product: Real double-precision Reduction	
	Environment:
		u, v: link
		product: create
	Compute:
		"" (Space B) { do { Space A:product = reduce("sum", u[i]*v[i]) } for i in u }
	Partition(b): 
		Space A <un-partitioned> {u, v}
		Space B <1D> divides Space A partitions { u, v: block_size(b) }

Task "CSR Matrix Vector Multiply":
	Define:
		columns, rows: 1D Array of Integer	
		values, v, w: 1D Array of Real double-precision
	Environment:
		values, columns, rows, v: link
		w: create
	Initialize:
		w.dimension = rows.dimension
	Compute:
		"" (Space A) {
			start = rows.local.dimension1.range.min
			if (start == 0) { start = -1 }
			do {	if (i > 0) {
					beginIndex = rows[i - 1] + 1
				} else {
					beginIndex = 0
				}
				endIndex = rows[i]
				do {
					w[i] = w[i] + values[j] * v[columns[j]] 
				} for j in columns and j >= beginIndex and j <= endIndex
			} for i in rows and i > start
		}	
	Partition(r):
		Space A <1D> {
			values, columns, v: replicated
			w: block_size(r)
			rows: block_size(r) padding(1, 0)
		}
